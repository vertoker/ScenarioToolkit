Перед тем, как добавлять новую версию модели, прочитайте заметку о совместимости
[вот тут](http://gitlab.novatrans.local/unity-packages/scenario-framework/-/wikis/data/compatibility)

## Изменения по версиям
Тут должны записываться все изменения во всех классах моделей

### V6 - Тотальное обновление
В этой версии были обновлены ВСЕ модели данных и некоторые очень удобные изменения

- `ScenarioGraph` и `EditorGraph` - полностью переписаны, интерфейс унифицирован и протестирован
- `FlowNode` - новый подвид ноды, именно им оперирует сценарий
- Теперь ноды имеют более явный механизм хеширования
  - `IScenarioLink` - теперь их хеш является смешиванием хешей 2 нод
  - `IEditorGroup` - теперь они имеют самостоятельные хеши

### V5 - Форматирование и вариативность
В этой версии были добавлены вариативная загрузка, форматирование json и выборочный конец

- `SubgraphNodeV5` - теперь появилось несколько источников загрузки у саб-сценариев
- `ScenarioGraphV5` и `EditorGraphV5` - изменённое положение, теперь оно стало читабельнее
- `EndNodeV5` - добавлен `bool instantEnd`, при котором он завершает сценарий сразу же

### V4 - port ноды
В этой версии были добавлены новые ноды для удобства создания сценариев

- `PortInNodeV4` и `PortOutNodeV4` - связанные ноды, который делает редирект из `in` в `out` 
и да это буквально костыли чтобы не чинить редактор

### V3 - данные для редактора
В этой версии были добавлены дополнительные данные для элементов в редакторе

- `EditorGraphV3` - были изменены `x` и `y` на `Position` нод и убран `ContextType`

### V2 - контекст, переменные и заметки
В этой версии был добавлен контекст и для переменных был изменён сабграф (тоже часть переменных)

- `ScenarioContextV2` - дополнительные данные для самого сценария. Пока что содержит 
только реализацию переменных

Как выглядят переменные внутри
- `Dictionary<int, List<IComponentVariables>> NodeOverrides` - места, где поля в компонентах должны
поменять значения в переменные
- `Dictionary<string, ObjectTyped> Variables` - те самые переменные, они есть 
в `ScenarioContextV2` (LVE) и в `SubgraphNodeV2` (NVE). Для каждого саб-сценария они смешиваются 
по правилам и создают уникальный контекст переменных

- `NoteNodeV2` - абстрактная нода, которая просто хранит форматируемый текст в виде комментария
в самом сценарии

### V1 - единая модель
Первая версия нового сценария, основная цель которого - объединить обе V0 модели под одной моделью.
Именно тут началась вся эта вещь с версионированием моделей и конвертацией при загрузке.
Чтобы полностью отойти от V0, были обновлены ВСЕ модели

- `ScenarioModelV1` - единая модель для сохранения, в ней хранятся абсолютно все данные модели для всего
- `ScenarioGraphV1` - новая модель runtime данных
- `EditorGraphV1` - новая модель editor данных

Исходный код всех моделей не изменился, я просто сделал объединение данных в одну модель.
Изменил я ВСЕ модели только для двух вещей: сделать нормальные имена и добавить интерфейсы

Именно с этой версии ЛЮБАЯ работа с моделью происходит через интерфейсы. Так было сделано, чтобы меняя модель,
не приходилось менять её везде. Сценарий просто работает с абстракцией, а не с самой моделью

### V0 - старые модели
Исходная модель до перехода на новую версию. Все сценарии, сделанные версии Scenario v1.x.x обладают этой моделью.
Все сценарии, которые сделаны на Scenario до введения версий не поддерживаются!

- `ScenarioData` - исходная runtime модель, содержит только информацию для `ScenarioPlayer`
- `SerializableGraphElements` - исходная editor модель, содержит только информацию для `ScenarioEditor`
- `Graph` - граф, который и проигрывался в `ScenarioPlayer`

Также стоит понимать, что `SerializableGraphElements` не хранит `Graph`, он хранит только "обёртки"
над обычными нодами

Обычная runtime нода - `ScenarioNode`, editor нода - `SerializableNodeElement`, хранит
в себе дополнительную информацию для редактора и также саму `ScenarioNode`

Существовало 2 модели: runtime и editor, где были модели `SerializableNodeElement` и `ScenarioData` соответственно. 
Конвертация editor в runtime называлась export, и наоборот - import. 
Сделано было преимущественно для оптимизации памяти, но это вызывало большие сложности в работе
